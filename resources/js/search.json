[[{"i":"#","p":["Quillscript, formerly known as Snowfall, is an Unreal Engine code plugin. It controls the story and narrative flow for RPGs, visual novels, and other story-driven games. Including player choices, story branching, conditions, code integration, and much more. All of that is done through an easy-to-use screenplay-style scripting language."]},{"l":"For Writers","p":["Writers have a screenplay-style scripting language to author their stories."]},{"l":"For Artists","p":["UI designers can easily create their own Dialog Boxes and Selection Boxes widgets using UMG full power."]},{"l":"For Programmers","p":["Programmers can run their own custom code within script, either Blueprint or C++."]},{"l":"Quillscript Language","p":["Using a simple set of story writing rules, which includes essential functionalities, like variables, conditions, choices, branching, and code execution; game developers, have a powerful yet straightforward markup language to work with, made with game writers in mind.","A scripting-based dialogue has many advantages over common dialogue systems like spreadsheets, graphs, and data assets. Scripts are plain-text files, meaning they are sequential structures, faster to write and iterate, and simpler to review, edit, follow, and track, just as source-control friendly."]},{"l":"Features","p":["Any text editor can be used, there are no spreadsheets or complex data tables","Compatible both with Unreal Engine Blueprints and C++","Conditions and conditional branching","Dialogue and player choices","Easy to create a custom User Interface using UMG full power","Easy to customize and extend","Easy to use, no setup required","Execute any Engine's or Project's Blueprint/C++ code from script and capture the return back to script","Full Blueprint and C++ support","Integrates with any save system for persistence","Join our Discord server to get help and share your projects","Localizable out of the box","Optional Visual Studio Code extension for syntax highlighting and autocompletion","Story flow control and navigation","Syntax highlighting and autocompletion for Quillscript Language","To start with Quillscript, you need Unreal Engine installed and basic knowledge of how to use Unreal's Editor. Follow our Getting Started guide to begin authoring stories within Unreal Engine.","Variables and variables replacement","Video tutorials"]}],[{"l":"Getting Started","p":["If you are a beginner with Quillscript Plugin, this article helps you start from scratch.","Follow the steps below to get your project up and running and create your own stories.","You can also download our sample project."]},{"l":"Step by Step","p":["Step 1 - Enable Quillscript in your Project","Add Quillscript to the Engine through the Epic Games Launcher","Create and/or start a project","Go to Edit Plugins Installed Gameplay and enable Quillscript","Restart the Editor","Step 2 - Write your Story","Create a plain text file using your preferred text editor software and write your story following Quillscript Language rules. Save it with a .qsc extension.","We provide sample scripts you can use to test and experiment.","Drag your script file into Unreal Editor's content browser. This action will generate a Quillscript Asset, which is a resource that contains your script and can be used within the Unreal Editor for various purposes.","Step 3 - Play your Story","Go where you want to start your story, add a Play Script node, and select your new Quillscript Asset.","For the sake of this guide, we're starting the story at the Begin Play event of the open Level, but you can use this node wherever fits your case better, like a collision box overlapping event or button click event.","Play your game, and watch your story happen"]},{"l":"Video Tutorial"},{"i":"where-should-i-go-next","l":"Where Should I Go Next?","p":["The recommended next step is to familiarize yourself with the base language elements: Dialogue, Option, Label, Router, Command, Condition, Directive, Tag, and Comment.","When you feel confident that you know and understand the basics of each language element, we recommend you move to the Guides or Coding and Design sections.","Neither of those sections is required to be read in order; they are meant to be standalone guides, although often, it is considered that you have a basic understanding of prerequisite elements."]}],[{"l":"Dialogue","p":["An essential element of any text-based story is dialogue. Even in purely narrated games, the narrator has to say something or expose events and ideas to the player.","A Dialogue statement is composed of two or more lines.","The first line starts with - (dash), immediately followed by a whitespace. The dialog metadata represents information like the speakerâ€™s name and conditions.","The subsequent lines are the dialogue itself, the sentence being said.","As a best practice, we use a . (dot) to express this is a narrator's text.","You can write character interactions putting together as many dialogues as necessary to create a conversation."]}],[{"l":"Repeater","p":["It's common to have a story section where the same character talks successively, causing repetition. You can use this shortcut to avoid repetitive Dialogue header lines. The Repeater is replaced by the last valid Dialogue header line.","A Repeater is defined by a ... (Triple Dots).","A repeater copies the character name, conditions, and tags."]}],[{"l":"Gate","p":["Split a dialogue into two texts, one for true condition, and other for false","By default, when a dialogue condition fails, that dialogue line is ignored. A gate can select a different dialogue text if the condition fails.","A Gate is defined by a --- (Triple Dashes).","Also, with multiline dialogues:"]}],[{"l":"Option","p":["Another essential element for games with story branching is asking the player what they want to do or say in a specific situation. This is expressed in Quillscript as an Options collection.","An Option statement starts with an * (asterisk), immediately followed by a whitespace.","You can sequence as many options as you want; just remember to design your Selection Box widget accordingly."]},{"l":"Multiline Text Option","p":["Options' texts can also come in multiple lines, using a second asterisk, and adding the option text in the following line."]},{"l":"Navigation","p":["As you can see, the above options do nothing after being chosen. You can use an option to move to a desired point of the story by concatenating a Router as instruction."]},{"l":"Execute Commands","p":["Another common use is executing a Command as instruction within an option, like handling a variable or calling a function."]}],[{"l":"Dynamic Options","p":["\uD83D\uDEA7 Under construction \uD83D\uDEA7"]}],[{"l":"Label","p":["Labels are markers in specific points of your script flow. They are used as routing points to navigate from one point of the script to another, creating story branches and story flow control.","A Label statement starts with an @ (At Sign), immediately followed by a whitespace.","The label name must be a static name with no variables or text replacements that can alter it during runtime.","As written in the example above, all statements below the declaration of a label belong to that label section until another label is declared."]},{"l":"Label as Instruction","p":["Any statement can be labeled by adding a label as instruction to it. Router statements can use these labels as any other label statement.","It's important to notice that statements can be jumped if they belong to a label statement with a false condition or when they are within a condition statement that is also false. When a router statement points to a label instruction, the flow goes to that point, ignoring any parenting condition and evaluating only the target statement condition, if any."]},{"l":"Display Name","p":["When naming labels, it's common to emerge project patterns that are often non-friendly, containing dots, slashes, prefixes, postfixes, and other marks.","If your project shows labels' names to users for some reason, like in a story tracker, these names are not ideal to be displayed to other developers or players.","You can type a free text line below your label declaration to add a user-friendly name.","Differently from the label declaration itself, which must be a static name, a display name can use variables, replacements, rich text tags, and be formatted or modified by custom code."]}],[{"l":"Covert","p":["A covert label has the same behavior as a standard label, except that a covert label won't play unless explicitly called by a Router. This means if the script flow ever reaches a covert label, it jumps to the following standard label.","A Covert Label starts with <@> (Less Than, At Sign, and Greater Than), immediately followed by a whitespace.","In the example above, the @Where and @Eat labels only play if selected, and the story proceeds to @Continue jumping any covert labels on its flow."]},{"l":"Covert Label as Instruction","p":["If a covert label is used as an instruction in other types of statements, that statement is also jumped unless it is called directly by a router."]}],[{"l":"Template","p":["Templates are a specific type of covert labels that receive entry arguments. A variable is created for each argument and exists until a new label statement is played.","This can reduce repetitive lines and play specific sections of a story that need entry parameters.","Since templates are also covert labels, they can be declared using either @ or <@>","After naming the label, enumerate a list of arguments between parentheses, and separate by commas","Template argument variables start with @","On the router statement, pass the values for each argument in the same order."]},{"l":"Template as Instruction","p":["A label instruction can also be a template. In this case, the statement only plays if directly called by a router, since it becomes a covert statement.","Template variables are created for this statement play and deleted on the following statement play."]}],[{"l":"Router","p":["Routers are navigation controllers to move from one point of the story to a given label, by name. Its main functionality is control where the story should move to, based on player choices, variable values, and custom code.","A Router statement starts with a -> (Dash and Greater Than), immediately followed by a space."]},{"l":"Router as Instruction","p":["A Router can also be concatenated to other statements and used as an instruction.","In Dialogue, Label, Command, and Other Router statements, a router instruction is executed only if the statement conditions fail.","In Option statements, a router instruction is executed when that option is selected."]}],[{"l":"Channel","p":["A Channel memorises the point where a Router was played, and return to that point when the target label finishes to play.","A Channel statement starts with a <-> (Less Than, Dash and Greater Than), immediately followed by a space.","In the example above, after moving to @Answer, the script flow moves back to line 14, continuing after the Channel. The same occurs on line 20."]}],[{"l":"Travel","p":["Travel is actually a built-in function disguised as a Router statement. It works as other routers, navigating from that point to a given target, but differently from a Router statement, the Travel built-in function allows you to target another script.","The target Script is referenced using its id or Script Reference by Path.","You can also route directly to a label inside the target Script.","Be aware that the Travel built-in function will immediately terminate the current script playing and start the target Script in a new Interpreter instance."]},{"l":"Travel Pass","p":["It's often required to keep the current script and interpreter settings while traveling from one script to another. The $ Travel built-in function will start the new script in a clean instance.","If you need to keep the current settings, use the $ TravelPass instead. It works the same as $ Travel, but it makes a copy of the current Interpreter and keeps Interpreter and Script settings."]}],[{"l":"Command","p":["It's often required to execute programming code during your script play. Command statements can perform two tasks: Handle Quillscript Variables and Call Functions.","Quillscript is completely compatible with Unreal Engine programming, being it Blueprint Visual Scripting or C++, you can call almost any function from your script at any point.","A Command statement starts with a $ (Dollar Sign), immediately followed by a space."]},{"l":"Command as Instruction","p":["A Command can also be concatenated to Dialogue, Option, and other Command statements as an instruction.","Notice that the command marker $ (Dollar Sign) is not required in Command instructions and is implied.","You can concatenate as many Command instructions as required. They execute in the order they are written.","The Command instruction has a different behavior for each statement type.","Dialogue","Execute before the dialogue plays","Option","Execute when the option is selected","Command","Execute after the main command"]}],[{"l":"Quillscript Variables","p":["A variable is a named location in memory that holds a value.","To declare a Quillscript variable, type the desired name, and use the = (Assignment Operator) to assign a value.","Once assigned, you can use this data everywhere in your script and even in your Blueprint/C++ code."]},{"l":"Variable Type","p":["Quillscript is an inferred type language, meaning that the variable type is automatically deduced. There are three variable types: Switch, Number, and Text. The variable type is used to determine the behavior of this variable for each operator, a Number type variable can be used for math operations, for example."]},{"l":"Switch","p":["Represents an on/ off state, also known as Boolean."]},{"l":"Number","p":["For numeric values. Integers and floating points."]},{"l":"Text","p":["For string values."]},{"l":"Variable Access","p":["The variable mark describes how Quillscript interpreter handles its lifecycle and other automatized tasks."]},{"l":"Global","p":["By default, any Quillscript variable is global. Once created, a global variable can be used in any other script, allowing script intercommunication.","Use global variables when persistence or intercommunication is necessary, and use temporary variables otherwise, since persistent variables take memory space, increase save file size, and increase the duration of certain tasks, like variable replacement in texts and expressions."]},{"l":"Temporary Variables","p":["A Temporary Variable is a Quillscript variable that only exists during that script play. Temporary variables are automatically deleted when the script ends.","These variables are the preferred method for declaring variables when they don't need to exist after a script play. The use of these variables saves computing resources, since Quillscript has a smaller list of variables to search and apply tasks.","To declare a Temporary Variable, you name it starting with : (colons)."]},{"l":"Outer Variables","p":["Quillscript creates these variables to capture the return value of called functions. They have the same lifecycle of temporary variables and are deleted when the script ends. Check Function Call section for more details."]},{"l":"Template Variables","p":["These variables are created by Quillscript to be used as arguments by a template call. They are deleted when a label statement is reached. Check Template section for more details."]},{"l":"Assigning Variables","p":["Besides assigning static hard-coded values, variables also accept math expressions and other value concatenation methods."]},{"l":"Expressions","p":["You can assign a complete math expression to a single variable, from a simple addition to a complex equation.","It's possible to use other variable values in expressions. Notice the use of (brackets) to use a variable value instead of the literal string \"value\".","You can self-reference the assigned variable in an expression using a{&}.","Or use a reduced assignment operation."]},{"l":"Valid Operators","p":["-","!=","!==","*","/","%","^","+","<","<=","==","===",">",">=","A Text values is converted to numeric if possible, and to 0, otherwise.","Addition","and","Check if a and b are on","Check if a equals b(case insensitive)","Check if a equals b(case sensitive)","Check if a greater or equal b","Check if a greater than b","Check if a less or equal b","Check if a less than b","Check if a not equals b(case insensitive)","Check if a not equals b(case sensitive)","Check if a or b is on","Divide a by b","Division","Equal","Find the remainder of a divided by b","Greater","Greater Equal","Less","Less Equal","Logical AND","Logical OR","Multiplication","Multiply a for b","NOT Equal","off to 0","On Less, Less Equal, Greater, Greater Equal, Addition, Subtraction, Multiplication, Division, Remainder,and Power operations, it's required that the operands are numeric values. If a non-numeric value is passed, it is converted as follows:","on to 1","or","Power","Power a by b","Remainder","Strict Equal","Strict NOT Equal","Subtract b from a","Subtraction","Sum a plus b"]},{"l":"Constructor","p":["The operator constructor (:=) is used to assign a value to a variable only if that variable does not exist. This is useful for setup a script on its first play.","Complement the assignment (=) operator with the new (:) operator:","This is the same as $ x = 1 + 1, but is executed only if there isn't already a variable called x."]},{"l":"Text Concatenation","p":["The use of brackets allows the formation of texts by concatenation."]},{"l":"Nested Variables Replacement","p":["The use of brackets can also be done nesting a variable inside other variable brackets.","It is possible to use more elaborated replacement pattern if necessary"]},{"l":"Constants","p":["Constants work just like variables, they are assigned and handled the same way, but once created, they can't have their value changed.","Constants are declared on all uppercase."]},{"l":"Deleting Variables","p":["You should always remove variables that arenâ€™t required to be permanently stored, as the more variables there are, the more time it takes to execute some tasks.","To delete a variable, call the built-in function Delete and pass the variable's name.","Temporary variables are automatically deleted when the script ends, but you can delete them manually if needed."]},{"i":"localizing-variables-text","l":"Localizing Variables' Text","p":["Although being stored as an Unreal Engin's Text type, Quillscript's Text variables are marked as cultural invariants by default. If the value of a variable must be localized, set its value inside `` (backticks)"]},{"l":"Using Variables in Code","p":["Quillscript variables are stored as an Unreal Engine Map of Name to Text. This map is declared in Quillscript Subsystem and is accessible in Blueprints and C++. Check Quillscript Static Library for detailed usage."]},{"l":"Variable Modifier","p":["Check Register Variable Modifier and Unregister Variable Modifier.","\uD83D\uDEA7 Under construction \uD83D\uDEA7"]},{"l":"Hard Coding Default Variables","p":["\uD83D\uDEA7 Under construction \uD83D\uDEA7"]}],[{"l":"Function Call","p":["Quillscript can execute Blueprint/C++ functions using command lines.","Supposing you want to run a function with the following signature.","Must be a UFunction","By default, you can pass only primary type parameters: Boolean (bool), Byte (uint8), Integer (int32), Integer64 (int64), Float (float/double), String (FString), Name (FName), Text (FText) and Enumerators (UEnum).","Although not a recommended practice, you can pass Null Pointers (nullptr), typing any string for that parameter. To pass a pointer to a valid reference, check Script References."]},{"l":"Built-in","p":["If the above function belongs to the Interpreter, including custom interpreters, you call it by typing its name and passing the parameters separated by spaces."]},{"l":"Named Object","p":["You can execute functions that belong to an instanced object by referencing its name, editor's name or display name. For example, if an object is named 'MyActor', start the function with an & (ampersand) followed by the object name, and place a dot between the object name and the function name.","Additionally, Quillscript also provides a Rename Object function to easily set a name for an object.","Avoid using whitespaces and special characters in object names for safety.","Although using the object's editor's name does work on the Play-in-Editor, and development and debug builds, it won't work on distribution builds (shipping). Therefore, using the object's editor's name should be avoided and used only for quick testing and prototyping. Use the object name or display name instead."]},{"l":"Shortcuts","p":["&BackgroundBox","&Character","&DialogBox","&GameInstance","&GameMode","&GameState","&Interpreter or &this","&Level","&Pawn","&PlayerCameraManager","&PlayerController","&PlayerState","&Script","&SelectionBox","&Target","Background Box Widget","Current Level Script Actor","Dialog Box Widget","Game Instance Object","Game Mode Object","Game State Object","Player Camera Manager Actor","Player Character Actor","Player Controller Actor","Player Pawn Actor","Player State Object","Script object","Script target object (Passed in the Play Script node)","Selection Box Widget","This script interpreter Actor","You can use these names to reference common Unreal Engine objects."]},{"l":"Script References","p":["In addition, you can create a list of object references to use in scripts. To add an object to the list, use the method below:","And it becomes available in script, by name.","These objects can also be passed as parameter variables to other functions if they match parameter type. A null pointer is passed otherwise.","Although the interpreter tries to check if the parameter type and the referenced object type are different, you should avoid passing an object with a different type, this can result in a crash.","Object references are also be captured when they are sent as return value of a function. For example, the function with the following signature:","Must be a UFunction","An object reference for the output parameter is added and becomes immediately available in script."]},{"l":"Script Reference By Path","p":["It's very common to pass an Unreal Engine asset as a parameter to a function. To avoid the need to create a named script reference for every asset required, script references can use the Unreal Engine path pattern to pass asset references without the need to previously name it.","The same method can be applied to pass class references:","Script assets will also reference these assets in the Reference Viewer."]},{"l":"Script Reference Search Paths","p":["Also, often your assets are all in the same folder. For such cases, you can add that folder to a list of \"Search Paths\", either project-wide on plugin settings, or per script on the script asset itself. An asset in this specified folder does not need to be referenced by its entire path, but just by its name.","For example, suppose we have a folder named \"Backgrounds\" on the content browser. Inside this folder are 3 texture assets named \"Classroom\", \"Street\", and \"Shop\". You add this folder to your project search paths and reference these assets by name, without the need to create a script reference manually.","Search Path: /Game/Backgrounds/"]},{"i":"object-actors-widgets-or-function-library-of-class","l":"Object, Actors, Widgets or Function Library of Class","p":["You can execute functions in all objects of a given class. For example, if an object has the class \"MyClass\", start the function with an ^ (Circumflex) and the class name.","Start with the module name and the class name."]},{"l":"Tagged Actors","p":["Start with the blueprint reference path, without the extension at the end:","You can execute functions that belong to instanced Actors using their tags. For example, if an Actor has the tag 'MyTag', start the function with a % (Percent Sign) and the tag name.","This method will execute the function in all actors with the specified tag."]},{"l":"Calling Nested Objects","p":["You can also call functions from nested objects. For example:","You cannot call functions from objects in arrays, sets, maps, and nested structs."]},{"l":"Return Values and Outer Parameters"},{"l":"Functions","p":["You can capture the return values of a called function and store it in a Quillscript variable.","Suppose you want to capture the return value of the following function.","Must be a UFunction","When this function is called by one of the methods above, the return values are stored in Quillscript Outer Variables, a particular type of temporary variable that exists during that script execution.","These variables are named like the return value and outer parameters. The following variables are created in the example above: $ReturnValue, $IntParam, and $StringParam"]},{"l":"Properties","p":["You can capture the value of an UObject property.","Suppose you want to capture the return value of the following properties.","Must be a UProperty","Call the variable by its path and use the property name as an outer variable.","And you can do the same for nested objects:","You cannot access properties from objects in arrays, sets, maps, and nested structs","It's also possible to retrieve an element from some container types using the :: separator.","From Arrays or Sets using the element index number:","The following types are supported: Boolean (bool), Byte (uint8), Integer (int32), Integer64 (int64), Float (float/double), String (FString) and Name (FName).","From Maps using the element key:","The following types are supported: Boolean (bool), Byte (uint8), Integer (int32), Integer64 (int64), Float (float/double), String (FString), Name (FName) and Enumerators (UEnum)."]},{"i":"localizing-parameters-text","l":"Localizing Parameters' Text","p":["Although being stored as an Unreal Engine's Text type, Quillscript's Text are culture-invariant by default. If the value of a parameter must be localized, set its value inside `` (backticks) and it will be changed to culture-correct."]},{"l":"Named Parameters","p":["Is a versatile feature that allows users to call functions with parameters passed in any order. This is achieved by explicitly naming the parameters using the @ParamName:ParamValue syntax. This approach enhances code readability and flexibility, making it easier to understand and edit. At the same time, it also lets the writer pass only the desired parameters in the desired order and omits unnecessary ones.","Consider the following function:","Must be a UFunction","In a Quillscript file, you can call this function like this."]}],[{"l":"Built-In Functions","p":["List all built-in functions available in script"]},{"l":"Flow"},{"i":"span-class-command-restart-span","l":"<span class=\"command\">Restart</span>","p":["Go back to the beginning of the script."]},{"i":"span-class-command-next-span","l":"<span class=\"command\">Next</span>","p":["Go to next Statement."]},{"i":"span-class-command-rollback-span","l":"<span class=\"command\">Rollback</span>","p":["Go to previous executed Statement."]},{"i":"span-class-command-repeat-span","l":"<span class=\"command\">Repeat</span>","p":["Restart current label statement."]},{"i":"span-class-command-done-span","l":"<span class=\"command\">Done</span>","p":["Advance to next label statement."]},{"i":"span-class-command-return-span","l":"<span class=\"command\">Return</span>","p":["Go back to last executed Router statement."]},{"i":"span-class-command-end-span","l":"<span class=\"command\">End</span>","p":["End this script."]},{"i":"span-class-command-kill-span","l":"<span class=\"command\">Kill</span>","p":["Same as $ End, but does not apply Script Settings After."]},{"i":"span-class-command-restore-span","l":"<span class=\"command\">Restore</span>","p":["Allows this scene to proceed."]},{"i":"span-class-command-stop-span","l":"<span class=\"command\">Stop</span>","p":["Prevents this scene from proceeding."]},{"i":"span-class-command-sleep-span","l":"<span class=\"command\">Sleep</span>","p":["Stops the script play, remove the script widgets from the screen, and apply Script Settings After.","This function is intended to stop a script play and restore the game to its default state until the scene is restored with the command $ Wakeup."]},{"i":"span-class-command-wakeup-span","l":"<span class=\"command\">Wakeup</span>","p":["Restore and continue a script play from a sleep state caused by the $ Sleep command."]},{"i":"span-class-command-wait-span","l":"<span class=\"command\">Wait</span>","p":["Stop script for a few seconds."]},{"i":"span-class-command-timer-span","l":"<span class=\"command\">Timer</span>","p":["Execute the given command after the given time."]},{"i":"span-class-command-travel-span","l":"<span class=\"command\">Travel</span>","p":["End current Script and play a new script from start or from label."]},{"i":"span-class-command-travel-pass-span","l":"<span class=\"command\">Travel Pass</span>","p":["End current Script and play a new script from start or from label.","It is the same as $ Travel, but instead of a new clean Interpreter, it makes a of the current Interpreter, keeping settings and changes. Also, it uses the same Script settings as the current Script object and passes them to the given script."]},{"l":"State"},{"i":"span-class-command-print-span","l":"<span class=\"command\">Print</span>","p":["Debugger function to print the given Quillscript variable's value."]},{"i":"span-class-command-delete-span","l":"<span class=\"command\">Delete</span>","p":["Delete the given Quillscript variable."]},{"i":"span-class-command-notify-span","l":"<span class=\"command\">Notify</span>","p":["Notify all registered observers in 'UQuillscriptSubsystem::OnNotified(FString)'."]},{"l":"Input"},{"i":"span-class-command-set-input-mode-span","l":"<span class=\"command\">Set Input Mode</span>","p":["Change the game input mode."]},{"i":"span-class-command-input-enable-span","l":"<span class=\"command\">Input Enable</span>","p":["Enable input, move input, and look input."]},{"i":"span-class-command-input-disable-span","l":"<span class=\"command\">Input Disable</span>","p":["Disable input, move input, and look input."]},{"i":"span-class-command-input-mode-span","l":"<span class=\"command\">Input Mode</span>","p":["Show mouse cursor."]},{"i":"span-class-command-hide-mouse-cursor-span","l":"<span class=\"command\">Hide Mouse Cursor</span>","p":["Hide mouse cursor."]},{"l":"User Interface"},{"i":"span-class-command-use-span","l":"<span class=\"command\">Use</span>","p":["Use the specified class or keyword for Dialog Box, Selection Box and Background Box and Sprite Box.","By Keywords:","Default: Reset all boxes classes to default.","DialogBox: Reset the Dialog Box class to default.","SelectionBox: Reset the Selection Box class to default.","BackgroundBox: Reset the Background Box class to default.","SpriteBox: Reset the Sprite Box class to default.","By Class Path:","C++ Class:/Script/Module.DialogBoxClass","Blueprint Class:/Game/Path/To/Folder/MyDialogBox.MyDialogBox"]},{"i":"span-class-command-show-dialog-box-span","l":"<span class=\"command\">Show Dialog Box</span>","p":["Add Dialog Box to viewport."]},{"i":"span-class-command-show-selection-box-span","l":"<span class=\"command\">Show Selection Box</span>","p":["Add Selection Box to viewport."]},{"i":"span-class-command-show-background-box-span","l":"<span class=\"command\">Show Background Box</span>","p":["Add Background Box to viewport."]},{"i":"span-class-command-remove-dialog-box-span","l":"<span class=\"command\">Remove Dialog Box</span>","p":["Remove Dialog Box from viewport."]},{"i":"span-class-command-remove-selection-box-span","l":"<span class=\"command\">Remove Selection Box</span>","p":["Remove Selection Box from viewport."]},{"i":"span-class-command-remove-background-box-span","l":"<span class=\"command\">Remove Background Box</span>","p":["Remove Background Box from viewport."]},{"i":"span-class-command-show-span","l":"<span class=\"command\">Show</span>","p":["Show Dialog Box and Selection Box."]},{"i":"span-class-command-hide-span","l":"<span class=\"command\">Hide</span>","p":["Hide Dialog Box and Selection Box."]},{"i":"span-class-command-background-span","l":"<span class=\"command\">Background</span>","p":["Change the background image on screen with a transition animation."]},{"i":"span-class-command-bg-span","l":"<span class=\"command\">Bg</span>","p":["An alias function for $ Background."]},{"i":"span-class-command-sprite-span","l":"<span class=\"command\">Sprite</span>","p":["Create a User Interface object to display an image on screen from the default SpriteBox class and set a Script Reference for the created object.","It is most useful to display, animate and handle character images and illustrations during dialogues."]},{"l":"Media"},{"i":"span-class-command-play-sound-span","l":"<span class=\"command\">Play Sound</span>","p":["Play a sound asset."]},{"i":"span-class-command-voice-span","l":"<span class=\"command\">Voice</span>","p":["Play a sound asset.","Same as: PlaySound {/Path} 'voice' volume 0"]},{"i":"span-class-command-music-span","l":"<span class=\"command\">Music</span>","p":["Play a sound asset.","Same as: PlaySound {/Path} 'music' volume 0"]},{"i":"span-class-command-sfx-span","l":"<span class=\"command\">SFX</span>","p":["Play a sound asset.","Same as: PlaySound {/Path} 'sfx' volume 0"]},{"i":"span-class-command-stop-sound-span","l":"<span class=\"command\">Stop Sound</span>","p":["Stop the sound asset playing."]},{"i":"span-class-command-stop-all-sounds-span","l":"<span class=\"command\">Stop All Sounds</span>","p":["Stop all sound assets from all channels."]},{"i":"span-class-command-play-animation-span","l":"<span class=\"command\">Play Animation</span>","p":["Play animation on target skeletal mesh."]},{"l":"Helper"},{"i":"span-class-command-roll-span","l":"<span class=\"command\">Roll</span>","p":["Roll a die. Select a random number in range."]}],[{"l":"Condition","p":["Another important aspect of creating story branches is Conditions. When writing a story, you often need a story section to be played only in specific states.","Conditions allow you to check if a specific statement or section should be played or ignored by running an expression evaluation first. If the evaluation returns on (true), the condition is successful, and the line is played. If the condition fails, the line is ignored.","A condition statement can optionally start with a ? (Question Mark)","A condition statement is named after its functionality","If: Check an initial condition","elseif: Check as many secondary conditions as needed","else: This section plays if all if and elseif conditions fail","A conditions statement sequence must always end with an endif marker","In the example above, the script section from line 6 to line 17 is played only if the condition on line 6 is evaluated as true.","Using elseif and else conditions are completely optional. You can use as many elseif as required.","You can nest if conditions inside each other, just remember to close each individual \"if's collection of statements\" with an endif statement, as shown above."]},{"l":"Expression","p":["A condition is always an expression, the same method used to assign value to a variable. Therefore, conditions can use the same operators and syntax used by command expressions and be as complex as required."]},{"l":"Condition as Instruction","p":["You can use a condition instruction within any other statement to check if that single statement can be played or should be ignored.","A condition instruction starts with a ? (Question Mark) followed by an expression.","A condition instruction is successful when its expression is evaluated as on and fails in any other case.","In the first dialogue, the interpreter checks if a previously created Quillscript variable has a value bigger or equal to 5. The second dialogue covers the remaining option, that is, if charisma is smaller than 5.","You can add as many conditions as needed to a single statement."]},{"i":"in-dialogue-router-and-command","l":"In Dialogue, Router, and Command","p":["If any condition instruction fails, the statement is ignored, and the script flow proceeds to the following statement."]},{"l":"In Option","p":["Conditions are pre-evaluated and passed to the Play event of the Selection Box widget as a Boolean parameter called Valid. This parameter does nothing by itself; itâ€™s delegated to the Selection Box widget to decide what to do with this information. In most cases, the widget hides, gray out, or lock invalid options."]},{"l":"In Label","p":["The label and its content are ignored if any condition instruction fails, and the script flow proceeds to the following label statement."]}],[{"l":"Directive","p":["Directives are tasks that can execute either during runtime or before a Script starts. They are intended for automation and do pre-processing tasks.","A Directive statement starts with a ~ (Tilde), immediately followed by a space and the directive name."]},{"l":"Start","p":["Defines a different starting point for this script.","By default, Quillscript scripts start at the beginning of the text file. With this directive, you can set a custom starting point.","If you have the Keep Script History setting enabled in Quillscript Settings, you can add an index to multiple usages of the Start Directive. The Interpreter will start the script at index 1 the first time this script is played, at index 2 on the second play, and so on."]},{"l":"Define","p":["Replaces all occurrences of a pre-defined string during parsing time.","It is also possible to add parameters to the Define directive separated from the definition name with a : (colon). Any occurrence of those parameters will be replaced by their equivalent in the directive usage.","Or multiple parameters separated by ; (semi-colon)"]},{"l":"Replace","p":["Replaces all occurrences of a pre-defined parameter, before the script starts."]},{"l":"Include","p":["Inserts the data of a given Quillscript Script asset, at this point, either by id or by path.","To include a Script by id, use the script id starting with a @.","To include a Script by path, use the script path, simple or complete.","Be aware not to cyclically include one script into another creating an infinite loop."]},{"l":"Import","p":["Inserts the data of a given Quillscript Script asset, at the start of this script, only once, either by id or by path.","To import a Script by id, use the script id starting with a @.","To include a Script by path, use the script path, simple or complete.","Be aware not to cyclically include one script into another creating an infinite loop."]},{"l":"Inject","p":["Inserts the content of a given label from an external script, at this point, either by id or by path.","To inject a label content by id, use the script id starting with a @.","To include a label content by path, use the script path, simple or complete.","Be aware not to cyclically include one script or label into another creating an infinite loop."]},{"l":"Checkpoint","p":["This directive halts the execution of the script until a specified condition is met. The Interpreter remains in a waiting state and does not proceed to the next line of code until the condition evaluates to true. The condition is an expression that can be evaluated.","It accepts a number parameter to set the delay in seconds between condition checks, this help to improve performance, it check every 0.1 seconds otherwise.","It is also possible to concatenate Command statements to execute before each conditions check."]}],[{"l":"Tag","p":["Tags allow you to decorate your script statements for specific behaviors in custom widgets and Interpreters. They are just additional metadata to be used by your own Blueprints/Classes; they do nothing by default.","A tag instruction starts with a # (Hashtag) followed by its name.","You can place multiple tags in a single instruction or concatenate multiple instructions, both methods result in the same array of tags. A statement can have as many tags as required.","As a usage example, your project may have a Dialog Box widget that shows your character expression when saying a sentence or a Selection Box widget that colorizes an option.","Your custom widgets will receive these tags as an Array of Strings in its Play event 'Tags' parameter."]},{"l":"Key-Value Pair","p":["A tag can be formatted in a key-value pair pattern using : (Colon) like the example below.","On your Interpreter or custom widget, you can check your tags and split the data."]},{"l":"Custom Patterns","p":["Notice that tags are simple strings, meaning you can use custom patterns and formats to pass data, and later, you code your widgets and/or Interpreter to identify these patterns and act accordingly.","For example, you can write a tag using commas or semicolons and split the data later in your custom code."]}],[{"l":"Special Tags","p":["Special tags are tags with built-in behavior. They are used to decorate statements to obtain specific plugin behaviors."]},{"l":"Once","p":["This Special Tag can be used if you want a statement to play only once, doesn't matter how many times the script flow passes through that point.","Keep Visited Statements must be enabled in Quillscript Settings for this tag to work"]},{"l":"Mark","p":["The #mark tag is used to tell the Interpreter to store a counter of how many times this statement played when the Keep Visited Statements setting is turned off."]}],[{"l":"Comment","p":["Comment lines are ignored by the Lexer and discarded on parsing time. They are useful for adding comments, notes, and general reminders directly to your script.","A comment statement starts with a // (Double Dash), immediately followed by a whitespace."]},{"l":"Inline Comment","p":["An inline comment is a comment within another statement line. It is set the same way as a line comment. Be aware that anything after an inline comment opening, is ignored by the parser."]},{"l":"Header Comment","p":["If a free text line is set before any other statement in script, these lines are called header comments and differ from usual comments because they don't have a comment marker. They are also ignored and discarded by the parser."]},{"l":"Section","p":["Sections are organizational brackets with no impact on how your script runs. Their goal is to help writers better organize sections of the story without the need for any workarounds.","They also allow you to use the folding feature in most editors, like Visual Studio Code.","You start a section with a line containing a single { (Open Bracket) and end it with another line containing a single } (Close Bracket)."]}],[{"l":"Free Text","p":["Syntax Highlighting Test"]}],[{"l":"Script"}],[{"l":"Interpreter"}],[{"l":"Subsystem"}],[{"l":"Widgets"}],[{"l":"Dialog Box"}],[{"l":"Selection Box"}],[{"l":"Background Box"}],[{"l":"Sprite Box"}],[{"l":"Quill"}],[{"l":"Tools"}],[{"l":"Settings"}],[{"l":"Settings Details"}],[{"l":"Console Commands"}],[{"l":"How-To"}],[{"l":"Quicky"}],[{"l":"Localization"}],[{"l":"Loops"}],[{"l":"Visual Studio Code Extension"}],[{"l":"Changelog"},{"i":"v2-4","l":"v2.4 |","p":["Changelog"]},{"i":"v2-3-2","l":"v2.3.2 |","p":["Changelog"]},{"i":"v2-3-1","l":"v2.3.1 |","p":["Changelog"]},{"i":"v2-3","l":"v2.3 |","p":["Changelog"]},{"i":"v2-2","l":"v2.2 |","p":["Changelog"]},{"i":"v2-1-4","l":"v2.1.4 |","p":["Changelog"]},{"i":"v2-1-3","l":"v2.1.3 |","p":["Changelog"]},{"i":"v2-1-2","l":"v2.1.2 |","p":["Changelog"]},{"i":"v2-1-1","l":"v2.1.1 |","p":["Changelog"]},{"i":"v2-1","l":"v2.1 |","p":["Changelog"]},{"i":"v2-0","l":"v2.0 |","p":["Changelog"]}],[{"i":"v24","l":"V2.4"}],[{"i":"v23","l":"V2.3"}],[{"i":"v231","l":"V2.3.1"}],[{"i":"v232","l":"V2.3.2"}],[{"i":"v22","l":"V2.2"}],[{"i":"v21","l":"V2.1"}],[{"i":"v211","l":"V2.1.1"}],[{"i":"v212","l":"V2.1.2"}],[{"i":"v213","l":"V2.1.3"}],[{"i":"v214","l":"V2.1.4"}],[{"i":"v20","l":"V2.0"}],[{"l":"Contact"},{"l":"Request Support","p":["discord.gg","support@quillscript.ink"]},{"l":"Other Links","p":["Quillscript Channel","Visual Studio Marketplace","Are you enjoying our plugin? Please rate us on FAB\uD83D\uDE04"]}]]