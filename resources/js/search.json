[[{"i":"#","p":["Quillscript, formerly known as Snowfall, is an Unreal Engine code plugin. It controls the story and narrative flow for RPGs, visual novels, and other story-driven games. Including player choices, story branching, conditions, code integration, and much more. All of that is done through an easy-to-use screenplay-style scripting language."]},{"l":"For Writers","p":["Writers have a screenplay-style scripting language to author their stories."]},{"l":"For Artists","p":["UI designers can easily create their own Dialog Boxes and Selection Boxes widgets using UMG full power."]},{"l":"For Programmers","p":["Programmers can run their own custom code within script, either Blueprint or C++."]},{"l":"Quillscript Language","p":["Using a simple set of story writing rules, which includes essential functionalities, like variables, conditions, choices, branching, and code execution; game developers, have a powerful yet straightforward markup language to work with, made with game writers in mind.","A scripting-based dialogue has many advantages over common dialogue systems like spreadsheets, graphs, and data assets. Scripts are plain-text files, meaning they are sequential structures, faster to write and iterate, and simpler to review, edit, follow, and track, just as source-control friendly."]},{"l":"Features","p":["Any text editor can be used, there are no spreadsheets or complex data tables","Compatible both with Unreal Engine Blueprints and C++","Conditions and conditional branching","Dialogue and player choices","Easy to create a custom User Interface using UMG full power","Easy to customize and extend","Easy to use, no setup required","Execute any Engine's or Project's Blueprint/C++ code from script and capture the return back to script","Full Blueprint and C++ support","Integrates with any save system for persistence","Join our Discord server to get help and share your projects","Localizable out of the box","Optional Visual Studio Code extension for syntax highlighting and autocompletion","Story flow control and navigation","Syntax highlighting and autocompletion for Quillscript Language","To start with Quillscript, you need Unreal Engine installed and basic knowledge of how to use Unreal's Editor. Follow our Getting Started guide to begin authoring stories within Unreal Engine.","Variables and variables replacement","Video tutorials"]}],[{"l":"Getting Started","p":["If you are a beginner with Quillscript Plugin, this article helps you start from scratch.","Follow the steps below to get your project up and running and create your own stories.","You can also download our sample project."]},{"l":"Step by Step","p":["Step 1 - Enable Quillscript in your Project","Add Quillscript to the Engine through the Epic Games Launcher","Create and/or start a project","Go to Edit Plugins Installed Gameplay and enable Quillscript","Restart the Editor","Step 2 - Write your Story","Create a plain text file using your preferred text editor software and write your story following Quillscript Language rules. Save it with a .qsc extension.","We provide sample scripts you can use to test and experiment.","Drag your script file into Unreal Editor's content browser. This action will generate a Quillscript Asset, which is a resource that contains your script and can be used within the Unreal Editor for various purposes.","Step 3 - Play your Story","Go where you want to start your story, add a Play Script node, and select your new Quillscript Asset.","For the sake of this guide, we're starting the story at the Begin Play event of the open Level, but you can use this node wherever fits your case better, like a collision box overlapping event or button click event.","Play your game, and watch your story happen"]},{"l":"Video Tutorial"},{"i":"where-should-i-go-next","l":"Where Should I Go Next?","p":["The recommended next step is to familiarize yourself with the base language elements: Dialogue, Option, Label, Router, Command, Condition, Directive, Tag, and Comment.","When you feel confident that you know and understand the basics of each language element, we recommend you move to the Guides or Coding and Design sections.","Neither of those sections is required to be read in order; they are meant to be standalone guides, although often, it is considered that you have a basic understanding of prerequisite elements."]}],[{"l":"Dialogue","p":["An essential element of any text-based story is dialogue. Even in purely narrated games, the narrator has to say something or expose events and ideas to the player.","A Dialogue statement is composed of two or more lines.","The first line starts with - (dash), immediately followed by a whitespace. The dialog metadata represents information like the speaker’s name and conditions.","The subsequent lines are the dialogue itself, the sentence being said.","As a best practice, we use a . (dot) to express this is a narrator's text.","You can write character interactions putting together as many dialogues as necessary to create a conversation."]}],[{"l":"Repeater","p":["It's common to have a story section where the same character talks successively, causing repetition. You can use this shortcut to avoid repetitive Dialogue header lines. The Repeater is replaced by the last valid Dialogue header line.","A Repeater is defined by a ... (Triple Dots).","A repeater copies the character name, conditions, and tags."]}],[{"l":"Gate","p":["Split a dialogue into two texts, one for true condition, and other for false","By default, when a dialogue condition fails, that dialogue line is ignored. A gate can select a different dialogue text if the condition fails.","A Gate is defined by a --- (Triple Dashes).","Also, with multiline dialogues:"]}],[{"l":"Option","p":["Another essential element for games with story branching is asking the player what they want to do or say in a specific situation. This is expressed in Quillscript as an Options collection.","An Option statement starts with an * (asterisk), immediately followed by a whitespace.","You can sequence as many options as you want; just remember to design your Selection Box widget accordingly."]},{"l":"Multiline Text Option","p":["Options' texts can also come in multiple lines, using a second asterisk, and adding the option text in the following line."]},{"l":"Navigation","p":["As you can see, the above options do nothing after being chosen. You can use an option to move to a desired point of the story by concatenating a Router as instruction."]},{"l":"Execute Commands","p":["Another common use is executing a Command as instruction within an option, like handling a variable or calling a function."]}],[{"l":"Dynamic Options","p":["\uD83D\uDEA7 Under construction \uD83D\uDEA7"]}],[{"l":"Label","p":["Labels are markers in specific points of your script flow. They are used as routing points to navigate from one point of the script to another, creating story branches and story flow control.","A Label statement starts with an @ (At Sign), immediately followed by a whitespace.","The label name must be a static name with no variables or text replacements that can alter it during runtime.","As written in the example above, all statements below the declaration of a label belong to that label section until another label is declared."]},{"l":"Label as Instruction","p":["Any statement can be labeled by adding a label as instruction to it. Router statements can use these labels as any other label statement.","It's important to notice that statements can be jumped if they belong to a label statement with a false condition or when they are within a condition statement that is also false. When a router statement points to a label instruction, the flow goes to that point, ignoring any parenting condition and evaluating only the target statement condition, if any."]},{"l":"Display Name","p":["When naming labels, it's common to emerge project patterns that are often non-friendly, containing dots, slashes, prefixes, postfixes, and other marks.","If your project shows labels' names to users for some reason, like in a story tracker, these names are not ideal to be displayed to other developers or players.","You can type a free text line below your label declaration to add a user-friendly name.","Differently from the label declaration itself, which must be a static name, a display name can use variables, replacements, rich text tags, and be formatted or modified by custom code."]}],[{"l":"Covert","p":["A covert label has the same behavior as a standard label, except that a covert label won't play unless explicitly called by a Router. This means if the script flow ever reaches a covert label, it jumps to the following standard label.","A Covert Label starts with <@> (Less Than, At Sign, and Greater Than), immediately followed by a whitespace.","In the example above, the @Where and @Eat labels only play if selected, and the story proceeds to @Continue jumping any covert labels on its flow."]},{"l":"Covert Label as Instruction","p":["If a covert label is used as an instruction in other types of statements, that statement is also jumped unless it is called directly by a router."]}],[{"l":"Template","p":["Templates are a specific type of covert labels that receive entry arguments. A variable is created for each argument and exists until a new label statement is played.","This can reduce repetitive lines and play specific sections of a story that need entry parameters.","Since templates are also covert labels, they can be declared using either @ or <@>","After naming the label, enumerate a list of arguments between parentheses, and separate by commas","Template argument variables start with @","On the router statement, pass the values for each argument in the same order."]},{"l":"Template as Instruction","p":["A label instruction can also be a template. In this case, the statement only plays if directly called by a router, since it becomes a covert statement.","Template variables are created for this statement play and deleted on the following statement play."]}],[{"l":"Router","p":["Routers are navigation controllers to move from one point of the story to a given label, by name. Its main functionality is control where the story should move to, based on player choices, variable values, and custom code.","A Router statement starts with a -> (Dash and Greater Than), immediately followed by a space."]},{"l":"Router as Instruction","p":["A Router can also be concatenated to other statements and used as an instruction.","In Dialogue, Label, Command, and Other Router statements, a router instruction is executed only if the statement conditions fail.","In Option statements, a router instruction is executed when that option is selected."]}],[{"l":"Channel","p":["A Channel memorises the point where a Router was played, and return to that point when the target label finishes to play.","A Channel statement starts with a <-> (Less Than, Dash and Greater Than), immediately followed by a space.","In the example above, after moving to @Answer, the script flow moves back to line 14, continuing after the Channel. The same occurs on line 20."]}],[{"l":"Travel","p":["Travel is actually a built-in function disguised as a Router statement. It works as other routers, navigating from that point to a given target, but differently from a Router statement, the Travel built-in function allows you to target another script.","The target Script is referenced using its id or Script Reference by Path.","You can also route directly to a label inside the target Script.","Be aware that the Travel built-in function will immediately terminate the current script playing and start the target Script in a new Interpreter instance."]},{"l":"Travel Pass","p":["It's often required to keep the current script and interpreter settings while traveling from one script to another. The $ Travel built-in function will start the new script in a clean instance.","If you need to keep the current settings, use the $ TravelPass instead. It works the same as $ Travel, but it makes a copy of the current Interpreter and keeps Interpreter and Script settings."]}],[{"l":"Command"}],[{"l":"Quillscript Variables"}],[{"l":"Function Call"}],[{"l":"Built-in Functions"}],[{"l":"Condition","p":["Another important aspect of creating story branches is Conditions. When writing a story, you often need a story section to be played only in specific states.","Conditions allow you to check if a specific statement or section should be played or ignored by running an expression evaluation first. If the evaluation returns on (true), the condition is successful, and the line is played. If the condition fails, the line is ignored.","A condition statement can optionally start with a ? (Question Mark)","A condition statement is named after its functionality","If: Check an initial condition","elseif: Check as many secondary conditions as needed","else: This section plays if all if and elseif conditions fail","A conditions statement sequence must always end with an endif marker","In the example above, the script section from line 6 to line 17 is played only if the condition on line 6 is evaluated as true.","Using elseif and else conditions are completely optional. You can use as many elseif as required.","You can nest if conditions inside each other, just remember to close each individual \"if's collection of statements\" with an endif statement, as shown above."]},{"l":"Expression","p":["A condition is always an expression, the same method used to assign value to a variable. Therefore, conditions can use the same operators and syntax used by command expressions and be as complex as required."]},{"l":"Condition as Instruction","p":["You can use a condition instruction within any other statement to check if that single statement can be played or should be ignored.","A condition instruction starts with a ? (Question Mark) followed by an expression.","A condition instruction is successful when its expression is evaluated as on and fails in any other case.","In the first dialogue, the interpreter checks if a previously created Quillscript variable has a value bigger or equal to 5. The second dialogue covers the remaining option, that is, if charisma is smaller than 5.","You can add as many conditions as needed to a single statement."]},{"i":"in-dialogue-router-and-command","l":"In Dialogue, Router, and Command","p":["If any condition instruction fails, the statement is ignored, and the script flow proceeds to the following statement."]},{"l":"In Option","p":["Conditions are pre-evaluated and passed to the Play event of the Selection Box widget as a Boolean parameter called Valid. This parameter does nothing by itself; it’s delegated to the Selection Box widget to decide what to do with this information. In most cases, the widget hides, gray out, or lock invalid options."]},{"l":"In Label","p":["The label and its content are ignored if any condition instruction fails, and the script flow proceeds to the following label statement."]}],[{"l":"Directive","p":["Directives are tasks that can execute either during runtime or before a Script starts. They are intended for automation and do pre-processing tasks.","A Directive statement starts with a ~ (Tilde), immediately followed by a space and the directive name."]},{"l":"Start","p":["Defines a different starting point for this script.","By default, Quillscript scripts start at the beginning of the text file. With this directive, you can set a custom starting point.","If you have the Keep Script History setting enabled in Quillscript Settings, you can add an index to multiple usages of the Start Directive. The Interpreter will start the script at index 1 the first time this script is played, at index 2 on the second play, and so on."]},{"l":"Define","p":["Replaces all occurrences of a pre-defined string during parsing time.","It is also possible to add parameters to the Define directive separated from the definition name with a : (colon). Any occurrence of those parameters will be replaced by their equivalent in the directive usage.","Or multiple parameters separated by ; (semi-colon)"]},{"l":"Replace","p":["Replaces all occurrences of a pre-defined parameter, before the script starts."]},{"l":"Include","p":["Inserts the data of a given Quillscript Script asset, at this point, either by id or by path.","To include a Script by id, use the script id starting with a @.","To include a Script by path, use the script path, simple or complete.","Be aware not to cyclically include one script into another creating an infinite loop."]},{"l":"Import","p":["Inserts the data of a given Quillscript Script asset, at the start of this script, only once, either by id or by path.","To import a Script by id, use the script id starting with a @.","To include a Script by path, use the script path, simple or complete.","Be aware not to cyclically include one script into another creating an infinite loop."]},{"l":"Inject","p":["Inserts the content of a given label from an external script, at this point, either by id or by path.","To inject a label content by id, use the script id starting with a @.","To include a label content by path, use the script path, simple or complete.","Be aware not to cyclically include one script or label into another creating an infinite loop."]},{"l":"Checkpoint","p":["This directive halts the execution of the script until a specified condition is met. The Interpreter remains in a waiting state and does not proceed to the next line of code until the condition evaluates to true. The condition is an expression that can be evaluated.","It accepts a number parameter to set the delay in seconds between condition checks, this help to improve performance, it check every 0.1 seconds otherwise.","It is also possible to concatenate Command statements to execute before each conditions check."]}],[{"l":"Tag"}],[{"l":"Special Tags"}],[{"l":"Comment"}],[{"l":"Free Text","p":["Syntax Highlighting Test"]}],[{"l":"Script"}],[{"l":"Interpreter"}],[{"l":"Subsystem"}],[{"l":"Widgets"}],[{"l":"Dialog Box"}],[{"l":"Selection Box"}],[{"l":"Background Box"}],[{"l":"Sprite Box"}],[{"l":"Quill"}],[{"l":"Tools"}],[{"l":"Settings"}],[{"l":"Settings Details"}],[{"l":"Console Commands"}],[{"l":"How-To"}],[{"l":"Quicky"}],[{"l":"Localization"}],[{"l":"Loops"}],[{"l":"Visual Studio Code Extension"}],[{"l":"Changelog"},{"i":"v2-4","l":"v2.4 |","p":["Changelog"]},{"i":"v2-3-2","l":"v2.3.2 |","p":["Changelog"]},{"i":"v2-3-1","l":"v2.3.1 |","p":["Changelog"]},{"i":"v2-3","l":"v2.3 |","p":["Changelog"]},{"i":"v2-2","l":"v2.2 |","p":["Changelog"]},{"i":"v2-1-4","l":"v2.1.4 |","p":["Changelog"]},{"i":"v2-1-3","l":"v2.1.3 |","p":["Changelog"]},{"i":"v2-1-2","l":"v2.1.2 |","p":["Changelog"]},{"i":"v2-1-1","l":"v2.1.1 |","p":["Changelog"]},{"i":"v2-1","l":"v2.1 |","p":["Changelog"]},{"i":"v2-0","l":"v2.0 |","p":["Changelog"]}],[{"i":"v24","l":"V2.4"}],[{"i":"v23","l":"V2.3"}],[{"i":"v231","l":"V2.3.1"}],[{"i":"v232","l":"V2.3.2"}],[{"i":"v22","l":"V2.2"}],[{"i":"v21","l":"V2.1"}],[{"i":"v211","l":"V2.1.1"}],[{"i":"v212","l":"V2.1.2"}],[{"i":"v213","l":"V2.1.3"}],[{"i":"v214","l":"V2.1.4"}],[{"i":"v20","l":"V2.0"}],[{"l":"Contact"},{"l":"Request Support","p":["discord.gg","support@quillscript.ink"]},{"l":"Other Links","p":["Quillscript Channel","Visual Studio Marketplace","Are you enjoying our plugin? Please rate us on FAB\uD83D\uDE04"]}]]